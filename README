prerequisites:

1. docker must be installed
    https://docs.docker.com/
2. virtual box must be installed
    https://www.virtualbox.org/wiki/Downloads
3. minikube must be installed
    "brew cask install minikube" or https://kubernetes.io/docs/tasks/tools/install-minikube/
4. kubectl must be installed
    "brew install kubernetes-cli" or https://kubernetes.io/docs/tasks/tools/install-kubectl/


// this will create a vm running kubernetes master
minikube start

// use this to view the vm ip address (ssh username: docker, password: tcuser)
kubectl cluster-info (or "minikube ip")

We will write a simple go server program to simulate our micro-service.
In ./siplehttpserver we created an go server will reply "Hello {/path}, I'm {IP address}".

You don't have to build docker image here, this is just to demonstrate the process
// build a simple go server docker image. Or just run "cd ./docker && ./buildSimpleServer.sh"
(If you encountered "golang.org/x/sys/unix not found", run "go get golang.org/x/sys/unix")
CGO_ENABLED=0 GOOS=linux go build -a -o main simplehttpserver
// tag and push the image to docker hub
docker build -t stardust1991/hellomain -f SimpleDockerfile .
docker push stardust1991/hellomain
rm main

From here we will need some kubernetes concepts
Prerequisites:
1. Understand Pods in Kubernetes
    https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/
2. Understand Controllers (ReplicaSet, Deployment in our case)
    https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
    https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
3. Understand Services
    https://kubernetes.io/docs/concepts/services-networking/service/

In ./kube directory, we've created several kubernetes configuration files.
We can use simple-deployment.yaml to create a deployment, this will bring up 3 hello server instances.
Run command:
kubectl create -f simple-deployment --save-config

run "kubectl get all -o wide" to get information about Pods, Deployments...

After deployment finished, let's add our server instances behind an abstraction called Service.
kubectl create -f simple-service --save-config

The service will be bound to Node port 30001 in the configuration.
So we can access our go server endpoint in several ways:
1. use the ip address get from "kubectl cluster-info", say 192.168.99.101,
    run "curl 192.168.99.101:30001/anything"
2. ssh into 192.168.99.101 (use docker:tcuser), get helloservice cluster-ip address from "kubectl get all -o wide", say 10.107.114.97,
    run "curl 10.107.114.97:7777/anything"
3. select any of your pod (or helloservice), say "hellodeployment-7475db8bd7-2kb46", run "kubectl port-forward hellodeployment-7475db8bd7-2kb46 8888:8080"
    (if it's service then run "kubectl port-forward service/helloservice 8888:7777")
    and in another terminal run "curl 127.0.0.1:8888/anything"

We will observe the requests are load balanced from the IP address in server's response.

Let's explore how the services communication happens in kubernetes . For this purpose we will host another go grpc server, which has an API to count bytes in string.
Implementation is under ./simplegrpcserver, our previous simple http server will call the grpc server, just to count the byte of a string (the url path)

In ./docker folder, we build and push the grpc server image similarly.

